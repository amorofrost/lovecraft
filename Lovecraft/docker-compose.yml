services:
  webapi:
    build:
      context: .
      dockerfile: Lovecraft.WebAPI/Dockerfile
    image: lovecraft-webapi:local
    container_name: lovecraft-webapi
    networks:
      - lovecraft-net
    ports:
      - "5001:5001"
    volumes:
      - ./certs:/app/certs:ro
    environment:
      - ASPNETCORE_URLS=https://+:5001
      - ASPNETCORE_Kestrel__Certificates__Default__Path=/app/certs/server.pfx
      - ASPNETCORE_Kestrel__Certificates__Default__Password=
      - Certificates__CaPath=/app/certs/ca.crt
      # Allowed client thumbprints (comma-separated) - override with env or .env
      - Certificates__AllowedClientThumbprints=${ALLOWED_CLIENT_THUMBPRINTS}
    restart: unless-stopped
    healthcheck:
      # Use HTTPS (port 5001). We allow insecure curl (-k) because the container
      # uses the server certificate from the `certs` volume. This healthcheck
      # verifies Kestrel is accepting TLS connections on 5001. The API is
      # configured to require client certificates, so present the PFX client
      # certificate here (use an empty password after the colon if it's
      # empty). We call the /health endpoint which exists in the app.
      test: ["CMD-SHELL", "curl -k --cert-type P12 --cert /app/certs/client.pfx: --fail https://localhost:5001/health || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 5

  telegrambot:
    build:
      context: .
      dockerfile: Lovecraft.TelegramBot/Dockerfile
    image: lovecraft-telegrambot:local
    container_name: lovecraft-telegrambot
    networks:
      - lovecraft-net
    volumes:
      - ./certs:/app/certs:ro
    environment:
      - CLIENT_CERT_PATH=/app/certs/client.pfx
      - CLIENT_CERT_PASSWORD=
      - WebApi__BaseUrl=https://lovecraft-webapi:5001/
      - ALLOWED_SERVER_THUMBPRINTS=${ALLOWED_SERVER_THUMBPRINTS}
      - TELEGRAM_BOT_TOKEN=${TELEGRAM_BOT_TOKEN}
      - ACCESS_CODE=${ACCESS_CODE}
    restart: unless-stopped
    healthcheck:
      # The WebAPI is configured to require client certificates in this setup.
      # Use the PFX (PKCS#12) file directly. If the PFX has no password, present an empty password with a trailing colon.
      # curl needs the cert type specified for P12 files.
      test: ["CMD-SHELL", "curl -k --cert-type P12 --cert /app/certs/client.pfx: --fail https://lovecraft-webapi:5001/health || exit 1"]
      interval: 15s
      timeout: 5s
      retries: 5

  blazor:
    build:
      context: .
      dockerfile: Lovecraft.Blazor/Dockerfile
    image: lovecraft-blazor:local
    container_name: lovecraft-blazor
    networks:
      - lovecraft-net
    ports:
      - "5002:5002"
    volumes:
      - ./certs:/app/certs:ro
    environment:
      - ASPNETCORE_URLS=https://+:5002
      - ASPNETCORE_Kestrel__Certificates__Default__Path=/app/certs/blazor_server.pfx
      - ASPNETCORE_Kestrel__Certificates__Default__Password=
      - Certificates__CaPath=/app/certs/ca.crt
      - WebApi__BaseUrl=https://lovecraft-webapi:5001/
      - BLZ_CLIENT_CERT_PATH=/app/certs/blazor_client.pfx
      - BLZ_CLIENT_CERT_PASSWORD=
      - ACCESS_CODE=${ACCESS_CODE}
    restart: unless-stopped
    healthcheck:
      # Verify the Blazor Server app responds over HTTPS on 5002. Present the client pfx for mutual TLS if needed.
      test: ["CMD-SHELL", "curl -k --cert-type P12 --cert /app/certs/blazor_client.pfx: --fail https://localhost:5002/ || exit 1"]
      interval: 15s
      timeout: 5s
      retries: 5

networks:
  lovecraft-net:
    driver: bridge
